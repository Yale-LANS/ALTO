#include "post_filters.h"
#include <limits>
#include <stdio.h>
#include <stdlib.h>
#include <iostream>

PostFilter::PostFilter()
	: _has_constraints(false)
	, _upper_bound(std::numeric_limits<double>::max())
	, _upper_tight(false)
	, _lower_bound(-1.0 * std::numeric_limits<double>::max())
	, _lower_tight(false)
{
	;
}

std::string PostFilter::StripIP(const std::string& ip_str)
{
	if (ip_str.find("ip") != std::string::npos)
		return ip_str.substr(5);
	else 
		return ip_str;
}

bool PostFilter::inConstraints(double value)
{
	if (!_has_constraints)
		return true;
	if ((!_upper_tight && value >= _upper_bound) || (_upper_tight && value > _upper_bound))
		return false;
	if ((!_lower_tight && value <= _lower_bound) || (_lower_tight && value < _lower_bound))
		return false;
	return true;
}

ALTOErrorCode PostFilter::readConstraints(Object& obj)
{
	if (obj.Find("constraints") == obj.End())
		_has_constraints = false;
	else
	{
		_has_constraints = true;
		// [TODO] Now it only supports one zone generated by the constraints
		Array& array = obj["constraints"];
		if (obj.Find("constraints")->type != ET_ARRAY)	
			return E_JSON_VALUE_TYPE;

		for (size_t i = 0; i < array.Size(); i++)
		{
			std::string& cons = ((String&)array[i]).Value();
			std::string opr = cons.substr(0, 2);
			double bound = std::strtod(cons.substr(2, cons.size() - 2).c_str(), NULL);
			if (opr == "lt" && bound < _upper_bound)
			{
				_upper_bound = bound;
				_upper_tight = false;
			}
			else if (opr == "gt" && bound > _lower_bound)
			{
				_lower_bound = bound;
				_lower_tight = false;
			}
			else if (opr == "le" && bound < _upper_bound)
			{
				_upper_bound = bound;
				_upper_tight = true;

			}
			else if (opr == "ge" && bound > _lower_bound)
			{
				_lower_bound = bound;
				_lower_tight = true;
			
			}
			else if (opr == "eq")
			{
				_lower_bound = _upper_bound = bound;
				_lower_tight = _upper_tight = true;
				break;
			}
			else
				continue;
		}		
	}
	return E_OK;
}

ALTOErrorCode JsonPIDSet::readJson(std::string& json_str)
{
	Object pl_obj;
	std::stringstream ss (std::stringstream::in | std::stringstream::out);
	ss << json_str;
	try
	{
		Reader::Read(pl_obj, ss);
	}
	catch (...)
	{
		return E_SYNTAX;
	}

	if (pl_obj.Find("pids") == pl_obj.End())
		return E_JSON_FIELD_MISSING;
	if (pl_obj.Find("pids")->type != ET_ARRAY)
		return E_JSON_VALUE_TYPE;
	
	Array& array = pl_obj["pids"];
	for (size_t i = 0; i < array.Size(); i++)
	{
		String& pid = array[i];
		_pid_set.insert(pid.Value());
	}
	return E_OK;
}

ALTOErrorCode JsonPIDMatrix::readJson(std::string& json_str)
{
	Object obj;
	std::stringstream ss (std::stringstream::in | std::stringstream::out);
	ss << json_str;

	try
	{
		Reader::Read(obj, ss);
	}
	catch(...)
	{
		return E_SYNTAX;
	}

	if (obj.Find("cost-mode") == obj.End())
		return E_JSON_FIELD_MISSING;
	if (obj.Find("cost-mode")->type != ET_STRING)
		return E_JSON_VALUE_TYPE;

	if (obj.Find("cost-type") == obj.End())
		return E_JSON_FIELD_MISSING;
	if (obj.Find("cost-type")->type != ET_STRING)
		return E_JSON_VALUE_TYPE;

	if (obj.Find("pids") == obj.End())
		return E_JSON_FIELD_MISSING;
	if (obj.Find("pids")->type != ET_OBJECT)
		return E_JSON_VALUE_TYPE;

	ALTOErrorCode code = readConstraints(obj);
	if (code != E_OK)
		return code;
	
	String& cost_mode = obj["cost-mode"];
	String& cost_type = obj["cost-type"];

	_cost_mode = cost_mode.Value();
	_cost_type = cost_type.Value();

	Object& mat = obj["pids"];

	if (mat.Find("srcs") == mat.End())
		return E_JSON_FIELD_MISSING;
	if (mat.Find("srcs")->type != ET_ARRAY)
		return E_JSON_VALUE_TYPE;

	if (mat.Find("dsts") == mat.End())
		return E_JSON_FIELD_MISSING;
	if (mat.Find("dsts")->type != ET_ARRAY)
		return E_JSON_VALUE_TYPE;

	Array& srcs = mat["srcs"];
	Array& dsts = mat["dsts"];

	for (size_t i = 0; i < srcs.Size(); i++)
	{
		String& pid = (String&)srcs[i];
		_srcs.insert(pid.Value());
	}

	for (size_t i = 0; i < dsts.Size(); i++)
	{
		String& pid = (String&)dsts[i];
		_dsts.insert(pid.Value());
	}
	return E_OK;
}

ALTOErrorCode JsonEndPointsProperty::readJson(std::string& json_str)
{
	Object obj;
	std::stringstream ss (std::stringstream::in | std::stringstream::out);
	ss << json_str;
	try 
	{
		Reader::Read(obj, ss);
	}
	catch(...)
	{
		return E_SYNTAX;
	}
		
	if (obj.Find("properties") == obj.End()) 
		return E_JSON_FIELD_MISSING;
	if (obj.Find("properties")->type != ET_ARRAY)
		return E_JSON_VALUE_TYPE;

	if (obj.Find("endpoints") == obj.End()) 
		return E_JSON_FIELD_MISSING;
	if (obj.Find("endpoints")->type != ET_ARRAY)
		return E_JSON_VALUE_TYPE;

	Array& array = obj["properties"];
	Array& array2 = obj["endpoints"];

	for (size_t i = 0; i < array.Size(); i++)
	{
		String& pid = (String&)array[i];
		_properties.insert(pid.Value());
	}

	for (size_t i = 0; i < array2.Size(); i++)
	{
		String& pid = (String&)array2[i];
		_end_points.insert(pid.Value());
	}

	return E_OK;
}

ALTOErrorCode JsonEndPointsCost::readJson(std::string& json_str)
{
	Object obj;
	std::stringstream ss (std::stringstream::in | std::stringstream::out);
	ss << json_str;
	
	try
	{
		Reader::Read(obj, ss);
	}
	catch(...)
	{
		return E_SYNTAX;
	}

	if (obj.Find("cost-mode") == obj.End())
		return E_JSON_FIELD_MISSING;
	if (obj.Find("cost-mode")->type != ET_STRING)
		return E_JSON_VALUE_TYPE;

	if (obj.Find("cost-type") == obj.End())
		return E_JSON_FIELD_MISSING;
	if (obj.Find("cost-type")->type != ET_STRING)
		return E_JSON_VALUE_TYPE;

	if (obj.Find("endpoints") == obj.End())
		return E_JSON_FIELD_MISSING;
	if (obj.Find("endpoints")->type != ET_OBJECT)
		return E_JSON_VALUE_TYPE;

	ALTOErrorCode code = readConstraints(obj);
	if (code != E_OK)
		return code;

	String& cost_mode = obj["cost-mode"];
	String& cost_type = obj["cost-type"];
	_cost_mode = cost_mode.Value();
	_cost_type = cost_type.Value();

	Object& mat = obj["endpoints"];
		
	if (mat.Find("srcs") == mat.End())
		return E_JSON_FIELD_MISSING;
	if (mat.Find("srcs")->type != ET_ARRAY)
		return E_JSON_VALUE_TYPE;

	if (mat.Find("dsts") == mat.End())
		return E_JSON_FIELD_MISSING;
	if (mat.Find("dsts")->type != ET_ARRAY)
		return E_JSON_VALUE_TYPE;

	Array& srcs = mat["srcs"];
	Array& dsts = mat["dsts"];

	for (size_t i = 0; i < srcs.Size(); i++)
	{
		String& ip = (String&)srcs[i];
		_srcs.insert(ip.Value());
	}

	for (size_t i = 0; i < dsts.Size(); i++)
	{
		String& ip = (String&)dsts[i];
		_dsts.insert(ip.Value());
	}

	return E_OK;
}


